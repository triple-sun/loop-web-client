// Generated by ts-to-zod
import { z } from "zod";
import { type Post, type PostMetadata, type PostEmbed, type PostPreviewMetadata, type PostActionResponse, PostType, PostState, PostPriority, PostEmbedType, PostAttachmentColor, PostActionStyle, PostActionType, PostActionDataSource } from "./posts";

export const postTypeSchema = z.enum(PostType);

export const postStateSchema = z.enum(PostState);

export const postPrioritySchema = z.enum(PostPriority);

export const postEmbedTypeSchema = z.enum(PostEmbedType);

export const postPriorityMetadataSchema = z.object({
    priority: postPrioritySchema,
    requested_ack: z.boolean().optional(),
    persistent_notifications: z.boolean().optional()
});

export const postImageSchema = z.object({
    format: z.string(),
    frameCount: z.number(),
    height: z.number(),
    width: z.number()
});

export const postAcknowledgementSchema = z.object({
    post_id: z.string(),
    user_id: z.string(),
    acknowledged_at: z.number()
});

export const postAttachmentColorSchema = z.enum(PostAttachmentColor);

export const postAttachmentFieldSchema = z.object({
    title: z.string().describe("A title shown in the table above the value.\nAs of"),
    value: z.string().describe("The text value of the field.\nIt can be formatted using Markdown.\nSupports"),
    short: z.boolean().optional().describe("Optionally set to true or false (boolean) to\nindicate whether the value is short enough to be displayed beside other values.")
});

export const postActionStyleSchema = z.enum(PostActionStyle);

export const postActionTypeSchema = z.enum(PostActionType);

export const postActionDataSourceSchema = z.enum(PostActionDataSource);

export const postActionOptionSchema = z.object({
    text: z.string(),
    value: z.string()
});

const postActionSchema = z.object({
    type: postActionTypeSchema.describe("Action type - button or select"),
    id: z.string().describe("A per post unique identifier.\nMust not contain \"_\" or \"-\""),
    name: z.string().describe("Give your action a descriptive name."),
    integration: z.object({
        url: z.string().describe("The actions are backed by an integration that handles HTTP POST requests when users select the message button.\nThe URL parameter determines where this action is sent. The request contains an application/json JSON string.\nAs of"),
        context: z.unknown().optional().describe("The requests sent to the specified URL contain the user ID, post ID, channel ID, team ID, and any context that was provided in the action definition. If the post was of type Message Menus, then context also contains the selected_option field with the user-selected option value. The post ID can be used to, for example, delete or edit the post after selecting a message button.")
    }).describe("Integration params")
});

export const postActionButtonSchema = postActionSchema.extend({
    type: z.literal(PostActionType.BUTTON),
    name: z.string().describe("Button text"),
    style: postActionStyleSchema.optional().describe("Button color\n\nButton actions support a style parameter to change the color of the button.\nThe possible values for style are: good, warning, danger, default, primary, and success.\n\nIt's also possible to pass a theme variable or a hex color, but we discourage this approach because it won't be resilient against theme changes.")
});

export const postActionSelectSchema = postActionSchema.extend({
    type: z.literal(PostActionType.SELECT),
    name: z.string().describe("Select text"),
    style: z.union([postActionStyleSchema, z.string()]).optional().describe("Select color"),
    options: z.array(postActionOptionSchema).optional(),
    data_source: postActionDataSourceSchema.optional().describe("Data source for options\n\nYou can provide a list of channels for message menus for users to select from.\nUsers can only select from public channels in their teams.\n\nSimilar to channels, you can also provide a list of users for message menus.\nThe user can choose the user who is part of the Mattermost system.")
});

export const postActionPayloadSchema = z.object({
    post_id: z.string(),
    channel_id: z.string(),
    user_id: z.string(),
    team_id: z.string().optional(),
    context: z.unknown()
});

export const postAnalyticsSchema = z.object({
    channel_id: z.string(),
    post_id: z.string(),
    user_actual_id: z.string(),
    root_id: z.string(),
    priority: postPrioritySchema.optional(),
    requested_ack: z.union([z.boolean(), z.undefined()]).optional(),
    persistent_notifications: z.union([z.boolean(), z.undefined()]).optional()
});

export const postOrderBlockSchema = z.object({
    order: z.array(z.string()),
    recent: z.boolean().optional(),
    oldest: z.boolean().optional()
});

export const messageHistorySchema = z.object({
    messages: z.array(z.string()),
    index: z.object({
        post: z.number(),
        comment: z.number()
    })
});

export const postActivityEntrySchema = z.object({
    postType: postTypeSchema,
    actorId: z.array(z.string()),
    userIds: z.array(z.string()),
    usernames: z.array(z.string())
});

export const postInfoSchema = z.object({
    channel_id: z.string(),
    channel_type: z.string(),
    channel_display_name: z.string(),
    has_joined_channel: z.boolean(),
    team_id: z.string(),
    team_type: z.string(),
    team_display_name: z.string(),
    has_joined_team: z.boolean()
});

const openGraphMetadataSchema = z.any();

const customEmojiSchema = z.any();

const fileInfoSchema = z.any();

const reactionSchema = z.any();

export const postAttachmentSchema = z.object({
    fallback: z.string().optional().describe("A required plain-text summary of the attachment.\nThis is used in notifications, and in clients that don't support formatted text (e.g. IRC)."),
    color: z.union([postAttachmentColorSchema, z.string()]).optional().describe("A hex color code that will be used as the left border color for the attachment.\nIf not specified, it will default to match the channel sidebar header background color."),
    pretext: z.string().optional().describe("An optional line of text that will be shown above the attachment.\nSupports"),
    text: z.string(),
    author_name: z.string().optional().describe("An optional name used to identify the author.\nIt will be included in a small section at the top of the attachment."),
    author_link: z.string().optional().describe("An optional URL used to hyperlink the author_name.\nIf no author_name is specified, this field does nothing."),
    author_icon: z.string().optional().describe("An optional URL used to display a 16x16 pixel icon beside the author_name."),
    title: z.string().optional().describe("An optional title displayed below the author information in the attachment."),
    title_link: z.string().optional().describe("An optional URL used to hyperlink the title. If no title is specified, this field does nothing."),
    fields: z.array(postAttachmentFieldSchema).optional().describe("Fields can be included as an optional array within attachments,\nand are used to display information in a table format inside the attachment."),
    actions: z.array(z.union([postActionButtonSchema, postActionSelectSchema])).optional().describe("Post action array (buttons/selects) used in interactive messages"),
    image_url: z.string().optional().describe("An optional URL to an image file (GIF, JPEG, PNG, BMP, or SVG)\nthat is displayed inside a message attachment."),
    thumb_url: z.string().optional().describe("An optional URL to an image file (GIF, JPEG, PNG, BMP, or SVG) that is displayed as\na 75x75 pixel thumbnail on the right side of an attachment.\n\nWe recommend using an image that is already 75x75 pixels, but larger images will be scaled down with the aspect ratio maintained."),
    footer: z.string().optional().describe("An optional line of text that will be displayed at the bottom of the attachment.\nFooters with more than 300 characters will be truncated with an ellipsis (\u2026)."),
    footer_icon: z.string().optional().describe("An optional URL to an image file (GIF, JPEG, PNG, BMP, or SVG) that\nis displayed as a 16x16 pixel thumbnail before the footer text.")
});

export const postPropsSchema = z.object({
    app_bindings: z.array(z.any()).optional(),
    attachments: z.array(postAttachmentSchema).optional(),
    from_bot: z.union([z.literal("true"), z.literal("false")]).optional(),
    metadata: z.unknown().optional()
});

export const postSchema: z.ZodSchema<Post> = z.lazy(() => z.object({
    id: z.string(),
    create_at: z.number(),
    update_at: z.number(),
    edit_at: z.number(),
    delete_at: z.number(),
    is_pinned: z.boolean(),
    user_id: z.string(),
    channel_id: z.string(),
    root_id: z.string(),
    original_id: z.string(),
    message: z.string(),
    type: postTypeSchema,
    props: postPropsSchema.optional(),
    hashtags: z.string(),
    pending_post_id: z.string(),
    reply_count: z.number(),
    file_ids: z.array(z.string()).optional(),
    metadata: postMetadataSchema,
    failed: z.boolean().optional(),
    user_activity_posts: z.array(postSchema).optional(),
    state: postStateSchema.optional(),
    filenames: z.array(z.string()).optional(),
    last_reply_at: z.number().optional(),
    participants: z.array(z.union([z.any(), z.string()])).optional(),
    message_source: z.string().optional(),
    is_following: z.boolean().optional(),
    exists: z.boolean().optional()
}));

export const postMetadataSchema: z.ZodSchema<PostMetadata> = z.lazy(() => z.object({
    embeds: z.array(postEmbedSchema),
    emojis: z.array(customEmojiSchema),
    files: z.array(fileInfoSchema),
    images: z.record(z.string(), postImageSchema),
    reactions: z.array(reactionSchema).optional(),
    priority: postPriorityMetadataSchema.optional(),
    acknowledgements: z.array(postAcknowledgementSchema).optional()
}));

export const postEmbedSchema: z.ZodSchema<PostEmbed> = z.lazy(() => z.object({
    type: postEmbedTypeSchema,
    url: z.string(),
    data: z.union([openGraphMetadataSchema, postPreviewMetadataSchema]).optional()
}));

export const postPreviewMetadataSchema: z.ZodSchema<PostPreviewMetadata> = z.lazy(() => z.object({
    post_id: z.string(),
    post: postSchema.optional(),
    channel_display_name: z.string(),
    team_name: z.string(),
    channel_type: z.string(),
    channel_id: z.string()
}));

export const postActionResponseSchema: z.ZodSchema<PostActionResponse> = z.lazy(() => z.object({
    update: postSchema.partial().optional(),
    ephemeral_text: z.string().optional()
}));
